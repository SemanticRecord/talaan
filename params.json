{
  "name": "Talaan",
  "tagline": "Semantic logging in Java over SLF4J",
  "body": "# Talaan\r\nSemantic logging in Java over SLF4J\r\n\r\nBuild status: [![Build Status] (https://travis-ci.org/SemanticRecord/talaan.svg?branch=master)](https://travis-ci.org/SemanticRecord/talaan \"Travis CI Build\")\r\n\r\nTalaan is a simple wrapper for [SLF4J] (http://www.slf4j.org/) based loggers which adds the ability to\r\ngenerate log statements by calling Java interface methods instead of having\r\nstrings scattered throughout your codebase. In addition, the library promotes\r\nstructured, strongly-typed, semantic logging instead of the more common\r\nunstructured logging used in most projects. Using semantic logging instead of\r\nunstructured logging helps your logs to be more easily consumed by tools such as\r\nSplunk.\r\n\r\nAn example of a typical unstructured log statement might look like the following:\r\n\r\n```java\r\nLogger logger = LoggerFactory.getLogger(YourClass.class);\r\nString user = \"Rick Grimes\";\r\nLocalDate businessDate = LocalDate.of(2016, 7, 1);\r\nString company = \"Alexandria\";\r\nlogger.info(\"Looking up invoices for user {} on date {} in company {}\", \r\n             user, businessDate, company);\r\n// business logic to perform lookup\r\n```\r\nLogged output will look like the following:\r\n```console\r\n  INFO Looking up invoices for user Rick Grimes on date 2016-07-01 in company Alexandria\r\n```\r\n\r\nA semantic approach would make it more machine readable: \r\n```java\r\nlogger.info(\"event={}, user={}, businessDate={}, company={}\", \"lookupInvoices\", \r\n            user, businessDate, company);\r\n```\r\nOutput will be: \r\n```console\r\n  INFO event=lookupInvoices, user=Rick Grimes, businessDate=2016-07-01, company=Alexandria\r\n```\r\n\r\nThe preceding example makes logging statements consistent and easier to parse\r\nbut we still end up with a bunch of strings scattered over our code base.  We also must remain disciplined across the codebase if we want logging statements which will be easily consumed by our log analysis tools.  If we\r\nhad an interface that we could call with strongly typed arguments then the\r\nlogging statement and its parameters can be derived automatically. \r\n\r\n```java\r\npublic interface BusinessLogger { \r\n  void lookupInvoices(String user, LocalDate businessDate, String company);\r\n}\r\nBusinessLogger logger = SemanticLogger.getLogger(BusinessLogger.class);\r\nlogger.lookupInvoices(user, businessDate, company);\r\n```\r\n\r\nThe output will be the same as the preceding example.\r\n\r\nThe advantages you get from such an approach are the following:\r\n\r\n* Consistent formatting in log statements\r\n* Easier refactoring\r\n* Logging methods centralized into a single place\r\n* Find callers of the logging statement across your project\r\n* Strong types help promote less defects\r\n* The possibility to mock the logging interface allows for fine-grained verification of the code\r\n\r\n## Additional Features\r\n\r\nTalaan features an annotation to customize event messages, control logging level, and enrich the \r\nlog statements with specific application codes.  Throwable's stack traces can also be included by \r\nadding the throwable as the last parameter to the method signature.  For example:\r\n\r\n```java\r\n@LogMessage(level = Level.ERROR, code = \"INVOICEAPP-1001\")\r\nvoid problemSavingRecord(long invoiceId, Stopwatch elapsedTime, Throwable t);\r\n```\t\r\n\r\nWill be output similarly to:\r\n```console\r\nERROR event=problemSavingRecord, code=INVOICEAPP-1001, invoiceId=1, elapsedTime=61.61 Î¼s\r\njava.lang.RuntimeException: Expected exception message\r\n\tat org.semanticrecord.talaan.SemanticLoggerTest.testThrowable(SemanticLoggerTest.java:92)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\t...\r\n```\r\n\r\n*Note:*\r\n\r\nThis project requires features from Java 8. In particular, in order to get\r\nmeaningful names for parameters declared on semantic logger interfaces you must\r\ncompile with the `-parameters` flag turned on. If using Maven a snippet similar\r\nto the following should suffice:\r\n\r\n```xml\r\n\t<plugin>\r\n\t\t<groupId>org.apache.maven.plugins</groupId>\r\n\t\t<artifactId>maven-compiler-plugin</artifactId>\r\n\t\t<version>3.5.1</version>\r\n\t\t<configuration>\r\n\t\t\t<source>1.8</source>\r\n\t\t\t<target>1.8</target>\r\n\t\t\t<compilerArgs>\r\n\t\t\t\t<arg>-parameters</arg>\r\n\t\t\t</compilerArgs>\r\n\t\t</configuration>\r\n\t</plugin>\r\n```\r\n\r\n## Similar Work\r\nThis project was inspired by the [JBoss Logging Tools] (https://developer.jboss.org/wiki/JBossLoggingTooling) project which takes an annotation based approach as well.  It differs from Talaan in that its primary focus seems to be on internationalization (i18n) support.  Talaan fulfills a different use case and requires no code generation.\r\n\r\nThere is also [LogMachine] (https://github.com/UnquietCode/LogMachine) which takes a [Fluent API] (https://en.wikipedia.org/wiki/Fluent_interface) approach.  LogMachine also provides extra formatting syntax and an interesting Topic-based logging functionality.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}